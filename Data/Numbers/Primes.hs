-- |
-- Module      : Data.Numbers.Primes
-- Copyright   : Sebastian Fischer
-- License     : BSD3
-- 
-- Maintainer  : Sebastian Fischer (sebf@informatik.uni-kiel.de)
-- Stability   : experimental
-- Portability : portable
-- 
-- This Haskell library provides an efficient lazy wheel sieve for
-- prime generation inspired by /Lazy wheel sieves and spirals of/
-- /primes/ by Colin Runciman
-- (<http://www.cs.york.ac.uk/ftpdir/pub/colin/jfp97lw.ps.gz>) and
-- /The Genuine Sieve of Eratosthenes/ by Melissa O'Neil
-- (<http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf>).
-- 
module Data.Numbers.Primes (

  primes, wheelSieve,

  isPrime, primeFactors

  ) where

import Data.List (sort)

-- | 
-- This global constant is an infinite list of prime numbers. It is
-- generated by a lazy wheel sieve and shared across the whole program
-- run. If you are concerned about the memory requirements of sharing
-- many primes you can call the function @wheelSieve@ directly.
-- 
primes :: Integral int => [int]
primes = wheelSieve 6

{-# SPECIALISE primes :: [Int]     #-}
{-# SPECIALISE primes :: [Integer] #-}

-- | 
-- This function returns an infinite list of prime numbers by sieving
-- with a wheel that cancels the multiples of the first @n@ primes
-- where @n@ is the argument given to @wheelSieve@. Don't use too
-- large wheels. The number @6@ is a good value to pass to this
-- function. Larger wheels improve the run time at the cost of higher
-- memory requirements.
-- 
wheelSieve :: Integral int
           => Int    -- ^ number of primes canceled by the wheel
           -> [int]  -- ^ infinite list of primes
wheelSieve k = reverse ps ++ map head (sieve p (cycle ns))
 where (p:ps,ns) = wheel k

{-# SPECIALISE wheelSieve :: Int -> [Int]     #-}
{-# SPECIALISE wheelSieve :: Int -> [Integer] #-}

-- |
-- Checks whether a given number is prime.
-- 
-- For "small" numbers this function uses trial division with primes
-- up to the square root of @n@.
--
-- For large numbers it checks if @n@ is divisible by the first couple
-- of primes and then performs a Rabin--Miller primality test.
--
-- The cutoff was determined by simple experimentation with average
-- running time of the test.
isPrime :: Integral int => int -> Bool
isPrime n | n < 2 = False
          | n < 300000000 = hasNoPrimeFactor n $ wheelSieve 6
          | otherwise = hasNoPrimeFactor n primesTo100 && isRabinMillerPrime n

{-# SPECIALISE isPrime :: Int     -> Bool #-}
{-# SPECIALISE isPrime :: Integer -> Bool #-}

-- |
-- Yields the sorted list of prime factors of the given positive
-- number.
-- 
-- This function uses trial division to take out "small" prime factors
-- and then switches to Pollard's rho algorithm.
--
-- For a large @n@ (with two prime factors of about equal size; the worst
-- case) it takes @O(n^(1/4)@ time. This algorithm should be practical
-- for inputs up to 100 bits in size.
primeFactors :: Integral int => int -> [int]
primeFactors n
    | n <= 0 = error $ "primeFactors: n should be positive (n=" ++ show n ++ ")"
    | otherwise = primeFactorsSmallFactorsOut n (take 2000 $ wheelSieve 6)
                    (sort . primeFactorsPollardRho)


{-# SPECIALISE primeFactors :: Int     -> [Int]     #-}
{-# SPECIALISE primeFactors :: Integer -> [Integer] #-}

-- Auxiliary Definitions
------------------------------------------------------------------------------

-- Sieves prime candidates by computing composites from the result of
-- a recursive call with identical arguments. We could use sharing
-- instead of a recursive call with identical arguments but that would
-- lead to much higher memory requirements. The results of the
-- different calls are consumed at different speeds and we want to
-- avoid multiple far apart pointers into the result list to avoid
-- retaining everything in between.
--
-- Each list in the result starts with a prime. To obtain composites
-- that need to be cancelled, one can multiply all elements of the
-- list with its head.
-- 
sieve :: (Ord int, Num int) => int -> [int] -> [[int]]
sieve p ns@(m:ms) = spin p ns : sieveComps (p+m) ms (composites p ns)

{-# SPECIALISE sieve :: Int     -> [Int]     -> [[Int]]     #-}
{-# SPECIALISE sieve :: Integer -> [Integer] -> [[Integer]] #-}

-- Composites are stored in increasing order in a priority queue. The
-- queue has an associated feeder which is used to avoid filling it
-- with entries that will only be used again much later. 
-- 
type Composites int = (Queue int,[[int]])

-- The feeder is computed from the result of a call to 'sieve'.
-- 
composites :: (Ord int, Num int) => int -> [int] -> Composites int
composites p ns = (Empty, map comps (spin p ns : sieve p ns))
 where comps xs@(x:_) = map (x*) xs

{-# SPECIALISE composites :: Int     -> [Int]     -> Composites Int     #-}
{-# SPECIALISE composites :: Integer -> [Integer] -> Composites Integer #-}

-- We can split all composites into the next and remaining
-- composites. We use the feeder when appropriate and discard equal
-- entries to not return a composite twice.
-- 
splitComposites :: Ord int => Composites int -> (int,Composites int)
splitComposites (Empty, xs:xss) = splitComposites (Fork xs [], xss)
splitComposites (queue, xss@((x:xs):yss))
  | x < z     = (x, discard x (enqueue xs queue, yss))
  | otherwise = (z, discard z (enqueue zs queue', xss))
 where (z:zs,queue') = dequeue queue

{-# SPECIALISE splitComposites :: Composites Int -> (Int,Composites Int) #-}
{-# SPECIALISE
    splitComposites :: Composites Integer -> (Integer,Composites Integer) #-}

-- Drops all occurrences of the given element.
--
discard :: Ord int => int -> Composites int -> Composites int
discard n ns | n == m    = discard n ms
             | otherwise = ns
 where (m,ms) = splitComposites ns

{-# SPECIALISE discard :: Int -> Composites Int -> Composites Int #-}
{-# SPECIALISE
    discard :: Integer -> Composites Integer -> Composites Integer #-}

-- This is the actual sieve. It discards candidates that are
-- composites and yields lists which start with a prime and contain
-- all factors of the composites that need to be dropped.
--
sieveComps :: (Ord int, Num int) => int -> [int] -> Composites int -> [[int]]
sieveComps cand ns@(m:ms) xs
  | cand == comp = sieveComps (cand+m) ms ys
  | cand <  comp = spin cand ns : sieveComps (cand+m) ms xs
  | otherwise    = sieveComps cand ns ys
 where (comp,ys) = splitComposites xs

{-# SPECIALISE sieveComps :: Int -> [Int] -> Composites Int -> [[Int]] #-}
{-# SPECIALISE
    sieveComps :: Integer -> [Integer] -> Composites Integer -> [[Integer]] #-}

-- This function computes factors of composites of primes by spinning
-- a wheel.
-- 
spin :: Num int => int -> [int] -> [int]
spin x (y:ys) = x : spin (x+y) ys

{-# SPECIALISE spin :: Int     -> [Int]     -> [Int]     #-}
{-# SPECIALISE spin :: Integer -> [Integer] -> [Integer] #-}

-- A wheel consists of a list of primes whose multiples are canceled
-- and the actual wheel that is rolled for canceling.
--
type Wheel int = ([int],[int])

-- Computes a wheel that cancels the multiples of the given number
-- (plus 1) of primes.
--
-- For example:
--
-- wheel 0 = ([2],[1])
-- wheel 1 = ([3,2],[2])
-- wheel 2 = ([5,3,2],[2,4])
-- wheel 3 = ([7,5,3,2],[4,2,4,2,4,6,2,6])
--
wheel :: Integral int => Int -> Wheel int
wheel n = iterate next ([2],[1]) !! n

{-# SPECIALISE wheel :: Int -> Wheel Int     #-}
{-# SPECIALISE wheel :: Int -> Wheel Integer #-}

next :: Integral int => Wheel int -> Wheel int
next (ps@(p:_),xs) = (py:ps,cancel (product ps) p py ys)
 where (y:ys) = cycle xs
       py = p + y

{-# SPECIALISE next :: Wheel Int     -> Wheel Int     #-}
{-# SPECIALISE next :: Wheel Integer -> Wheel Integer #-}

cancel :: Integral int => int -> int -> int -> [int] -> [int]
cancel 0 _ _ _ = []
cancel m p n (x:ys@(y:zs))
  | nx `mod` p > 0 = x : cancel (m-x) p nx ys
  | otherwise      = cancel m p n (x+y:zs)
 where nx = n + x

{-# SPECIALISE cancel :: Int -> Int -> Int -> [Int] -> [Int] #-}
{-# SPECIALISE
    cancel :: Integer -> Integer -> Integer -> [Integer] -> [Integer] #-}

-- We use a special version of priority queues implemented as /pairing/
-- /heaps/ (see /Purely Functional Data Structures/ by Chris Okasaki).
--
-- The queue stores non-empty lists of composites; the first element
-- is used as priority.
--
data Queue int = Empty | Fork [int] [Queue int]

enqueue :: Ord int => [int] -> Queue int -> Queue int
enqueue ns = merge (Fork ns [])

{-# SPECIALISE enqueue :: [Int]     -> Queue Int     -> Queue Int     #-}
{-# SPECIALISE enqueue :: [Integer] -> Queue Integer -> Queue Integer #-}

merge :: Ord int => Queue int -> Queue int -> Queue int
merge Empty y                        = y
merge x     Empty                    = x
merge x     y     | prio x <= prio y = join x y
                  | otherwise        = join y x
 where prio (Fork (n:_) _) = n
       join (Fork ns qs) q = Fork ns (q:qs)

{-# SPECIALISE merge :: Queue Int     -> Queue Int     -> Queue Int     #-}
{-# SPECIALISE merge :: Queue Integer -> Queue Integer -> Queue Integer #-}

dequeue :: Ord int => Queue int -> ([int], Queue int)
dequeue (Fork ns qs) = (ns,mergeAll qs)

{-# SPECIALISE dequeue :: Queue Int     -> ([Int],     Queue Int)     #-}
{-# SPECIALISE dequeue :: Queue Integer -> ([Integer], Queue Integer) #-}

mergeAll :: Ord int => [Queue int] -> Queue int
mergeAll []       = Empty
mergeAll [x]      = x
mergeAll (x:y:qs) = merge (merge x y) (mergeAll qs)

{-# SPECIALISE mergeAll :: [Queue Int]     -> Queue Int     #-}
{-# SPECIALISE mergeAll :: [Queue Integer] -> Queue Integer #-}

-- Primality testing.
------------------------------------------------------------------------------

-- Performs one step of the Rabin--Miller primality test.
--
-- testRabinMiller n (s, d) a returns:
-- False, meaning that a is a witness for the compositeness of n, or
-- True, meaning that n is a strong pseudo-prime for base a.
testRabinMiller :: Integral int
                => int          -- ^ n: the tested number
                -> (int, int)   -- ^ (s,d): such as 2^s*d == (n-1) and d is odd
                -> int          -- ^ a: base to be tested
                -> Bool
testRabinMiller n (s, d) a
    | b == 1 || b == n' = True
    | otherwise = not $ all (/= n') bs
    where
      n' = n - 1
      b = fastPow (\x y -> x*y `mod` n) a d
      bs = tail $ take (fromIntegral s) $ iterate (\x -> x*x `mod` n) b

-- Basic iterated squares exponentiation.
fastPow :: Integral i => (a -> a -> a) -> a -> i -> a
fastPow _ x 1 = x
fastPow (*) x k | r == 0 = xSquaredToK'
                | r == 1 = x * xSquaredToK'
    where
      (k', r) = quotRem k 2
      xSq = x * x
      xSquaredToK' = xSq `seq` fastPow (*) xSq k'

primesTo100 :: Integral int => [int]
primesTo100 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]

-- Rabin--Miller primality test.
--
-- We avoid dealing with generating random numbers we use a fixed set
-- of possible witnesses: the first 25 primes. (And though it is
-- proven that this cannot be enough for _all_ numbers, this should be
-- enough for numbers of imaginable size.)
--
-- For small numbers the simple trial division test is more efficient.
isRabinMillerPrime :: Integral int => int -> Bool
isRabinMillerPrime n
    | n <= 100 = n `elem` primesTo100
    | even n = False
    | otherwise = all (testRabinMiller n (s,d)) primesTo100
    where
      (s,d) = takeOut2s (n-1) 0
      
      takeOut2s d s | odd d = (s,d)
                    | otherwise = takeOut2s (d `quot` 2) $! s+1

-- 'hasNoPrimeFactor n ps' is True iff n is has no non-trival prime
-- divisor from the given list (ie. n itself can be a prime on the list).
--
-- Requirements: n is a positive integer, ps is a list of primes in
-- _increasing_ order.
hasNoPrimeFactor :: Integral int => int -> [int] -> Bool
hasNoPrimeFactor _ [] = True
hasNoPrimeFactor n (p:ps) | p*p > n = True
                          | n `rem` p == 0 = False
                          | otherwise = hasNoPrimeFactor n ps

-- Factorization.
------------------------------------------------------------------------------

-- For a positive composite integer @n@ find a non-trivial divisor
-- using Pollard's rho algorithm (with Brent's cycle finding method).
--
findFactorPollardRho :: Integral int
                        => int            -- ^ n: integer to be factorised
                        -> (int -> int)   -- ^ f: pseudo-random function mod n. (Should
                                          -- be a polinomial mod n, so it is a
                                          -- pseudo-random function for any prime
                                          -- factor p of n as well.)
                        -> int            -- ^ x0: starting value for f.
                        -> Maybe int      -- ^ Just d, where d is a non-trivial factor
                                          -- of n, or Nothing, if the pseudo-random
                                          -- function cycled before a factor was found.
findFactorPollardRho n f x0 = run (1::Integer) 0 x0 (f x0)
    where
      run c i x y
          | x == y = Nothing
          | d /= 1 = Just d
          | i == c = run (2*c) 0 y (f y)
          | otherwise = run c (i+1) x (f y)
          where
            d = gcd (abs (x - y)) n

-- Factorizes a positive integer @n@ using the Pollard's rho method.
--
-- Uses Rabin--Miller test for primality checking, so, for best performance small prime
-- factors should be taken out in advance.
primeFactorsPollardRho :: Integral int => int -> [int]
primeFactorsPollardRho n | n < 2 = []
                         | otherwise = pf n []
    where
      pf n | isRabinMillerPrime n = (n:)
           | otherwise = pf d . pf (n `quot` d)
           where
             d = ff n 1

      ff n a = case findFactorPollardRho n (\x -> (x*x + a) `rem` n) 2 of
                 Nothing -> ff n (a+1)
                 Just d -> d

-- Takes out small prime (given by the list ps) factors out of n, and for the remaining
-- number performs prime factorization using the provided restF function.
-- Returns the full list of prime factors.
primeFactorsSmallFactorsOut :: (Integral int) => int -> [int] -> (int -> [int]) -> [int]
primeFactorsSmallFactorsOut n ps restF = factors n ps
    where
      factors 1 _ = []
      factors n pps@(p:ps)
          | n < p*p = [n]
          | r == 0 = p : factors q pps
          | otherwise = factors n ps
          where
            (q,r) = n `quotRem` p
      factors n [] = restF n
